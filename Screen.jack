// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 512 rows (indexed 0..511, top to bottom)
 * of 256 pixels each (indexed 0..255, left to right). The top left pixel on 
 * the screen is indexed (0,0).
 */
class Screen {
    static boolean color;
    static Array p;


    /** Initializes the Screen. */
    function void init() {
        let p = Array.new(16);
        let p[0]=1;
        let p[1]= p[0]+p[0];
        let p[2]= p[1]+p[1];
        let p[3]= p[2]+p[2];
        let p[4]= p[3]+p[3];
        let p[5]= p[4]+p[4];
        let p[6]= p[5]+p[5];
        let p[7]= p[6]+p[6];
        let p[8]= p[7]+p[7];
        let p[9]= p[8]+p[8];
        let p[10]= p[9]+p[9];
        let p[11]= p[10]+p[10];
        let p[12]= p[11]+p[11];
        let p[13]= p[12]+p[12];
        let p[14]= p[13]+p[13];
        let p[15]= p[14]+p[14];
        let color =true;
        return;
    }

    /** Erases the entire screen. */
    function void clearScreen() {
        var int i;
        let i = 0;
        while (i < 8192) {
            do Memory.poke(16384+ i, 0);
            let i = i + 1;
        }
        return;
    }

    /** Sets the current color, to be used for all subsequent drawXXX commands.
     *  Black is represented by true, white by false. */
    function void setColor(boolean b) {

        let color= b;
        return;
    }

    /** Draws the (x,y) pixel, using the current color . */
    function void drawPixel(int x, int y) {
        var int address, data, mod, divX;
        if(~(Screen.checkPixelIndex(x,y))){ //check for invalidation
            do Sys.error(7);
        }
        let divX= Screen.divSixteen(x);
        let address =16384 +(y*32) + (divX);
        let data  = Memory.peek(address); //getting the data
        let mod = x &15; // modulo 16

        if (color) { //if the pixel need to be blackened
            let data = data|p[mod];
        }else{
            let data = data &(~(p[mod]));
        }
        do Memory.poke(address, data); //setting the new data
        return;

    }

    /** Draws a line from pixel (x1,y1) to pixel (x2,y2) ,  using the current color. */
    function void drawLine(int x1, int y1, int x2, int y2) {
        var int temp;
        if(~(Screen.checkLineIndex(x1,y1,x2, y2))){
            do Sys.error(8);
        }
        if(x1>x2){
            let temp =x1;
            let x1= x2;
            let x2= temp;
            let temp =y1;
            let y1= y2;
            let y2= temp;
        }
        if((x1=x2)|(y1=y2)){
            do Screen.drawStraightLine(x1,y1,x2,y2);
        }else{

            do Screen.drawDiagonalLine(x1,y1,x2,y2);

        }


        return;
    }

    /** Draws a filled rectangle whose top left corner is (x1, y1)
     * and bottom right corner is (x2,y2), using the current color. */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
        if(~(Screen.checkLineIndex(x1,y1,x2, y2))){
            do Sys.error(9);
        }
        while(~(y1>y2)){ // draw the rectangle
            do Screen.drawHorizontalLine(x1,y1,x2,y1);
            let  y1= y1+1;
        }
        return;
    }

    /** Draws a filled circle of radius r<=181 around (x,y), using the current color. */
    function void drawCircle(int x, int y, int r) {
        var int x1,y1,x2,y2,dy;
        if (r>181){
            do Sys.error(13);
        }
        if(~(Screen.checkCircleValidation(x,y,r))){ //check for invalidation
            do Sys.error(12);
        }

        let dy = ~(r)+1; //-r
        while(~(dy>r)){
            let x1 = x- Math.sqrt((r*r)-(dy*dy));
            let y1 = y+dy;
            let x2 = x+ Math.sqrt((r*r)-(dy*dy));
            let y2 = y+dy;
            do Screen.drawLine(x1,y1,x2,y2);
            let dy=dy+1;
        }

        return;
    }

    /** check the pixel coordinates index for invalidation */
    function boolean checkPixelIndex(int x, int y){
        if(x<0 | x>511 | y<0| y>255){
            return false;
        }else{
            return true;
        }
    }

    /** check the line coordinates indexes for invalidation */
    function boolean checkLineIndex(int x1, int y1, int x2, int y2){
        if(Screen.checkPixelIndex(x1,y1) & Screen.checkPixelIndex(x2,y2) ){
            return true;
        }else{
            return false;
        }
    }
    /**check the  circle validation*/
    function boolean checkCircleValidation(int x,int y,int r) {
        var int x1,x2,y1,y2;
        let x1= x-r;
        let x2 = x+r;
        let y1 = y-r;
        let y2 = y+r;
        if(~(Screen.checkPixelIndex(x,y)) & x1<0 & y1<0 & x2>511 & y2>255){
            return false;
        }else{
            return true;
        }
    }
    /** draws a straight line  - vertical or horizontal*/
    function void drawStraightLine(int x1, int y1, int x2, int y2){
        if(y1=y2){ // in case of vertical line
            do Screen.drawHorizontalLine(x1,y1,x2,y2);
        }else{ // in case of horizontal line
            do Screen.drawVerticalLine(x1,y1,x2,y2);
        }
        return;
    }
    /** draws a horizontal line*/
    function void drawHorizontalLine(int x1 , int y1, int x2, int y2){
        while(~(x1>x2)){
            do Screen.drawPixel(x1,y1);
            let x1 = x1 +1;
        }
        return;
    }

    /**draw a vertical line*/
    function void drawVerticalLine(int x1 , int y1 , int x2, int y2){
        var int temp;
        if(y1>y2){
            let temp= y1;
            let y1 =y2;
            let y2 =temp;
        }
        while(~(y1>y2)){
            do Screen.drawPixel(x1,y1);
            let y1 = y1+1;
        }
        return;
    }

    /** draw a diagonal line*/
    function void drawDiagonalLine(int x1, int y1, int x2 , int y2){
        var int a,b,diff,dy,dx,absDy;
        let a =0;
        let b =0;
        let diff= 0;
        let dx = x2- x1;
        let dy = y2 -y1;
        let absDy = Math.abs(dy);
        while(~((a>dx))&(~(b>absDy))){
            if(dy<0){
                do Screen.drawPixel(x1+a, y1-b);
            }else{
                do Screen.drawPixel(x1+a, y1+b);
            }
            if(diff<0){
                let a = a+1;
                if(dy<0){
                    let diff =diff-dy;
                }else{
                    let diff =diff +dy;
                }
            }else{
                let b =b+1;
                let diff =diff -dx;
            }
        }
        return;
    }

    function int divSixteen(int num) {
    		var int r, i;
    		let r = 0;
    		let i = 4;
    		while (i < 16) {
    			if ((num & p[i]) = p[i]) {
    				let r = r + p[i - 4];
    			}
    			let i = i + 1;
    		}
    		return r;
    	}

    function int getBitsArray(int index){
        return p[index];
    }
}
